import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { parse } from "csv-parse/sync";
import * as XLSX from "xlsx";
import { MongoClient } from "mongodb";
require("dotenv").config();

const uri = process.env.DATABASE_URL_MONGODB;
const clientPromise = new MongoClient(uri).connect();

export async function POST(req, context) {
    try {
        console.log("üìå Iniciando carga de clientes...");

        const { params } = context;
        if (!params || !params.id) {
            console.error("‚ùå Error: ID de campa√±a no v√°lido");
            return NextResponse.json({ error: "ID de campa√±a no v√°lido" }, { status: 400 });
        }

        const campanhaId = Number(params.id);
        if (isNaN(campanhaId)) {
            console.error("‚ùå Error: El ID de la campa√±a no es un n√∫mero v√°lido");
            return NextResponse.json({ error: "El ID de la campa√±a no es un n√∫mero v√°lido" }, { status: 400 });
        }

        console.log(`‚úÖ ID de campa√±a recibido: ${campanhaId}`);

        const formData = await req.formData();
        const file = formData.get("archivo");

        if (!file) {
            console.error("‚ùå Error: No se proporcion√≥ ning√∫n archivo");
            return NextResponse.json({ error: "No se proporcion√≥ ning√∫n archivo" }, { status: 400 });
        }

        console.log(`üìå Archivo recibido: ${file.name}`);

        const buffer = Buffer.from(await file.arrayBuffer());
        let clientes = [];

        if (file.name.endsWith(".xlsx") || file.name.endsWith(".xls")) {
            console.log("üìå Procesando archivo Excel...");
            const workbook = XLSX.read(buffer, { type: "buffer" });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            clientes = XLSX.utils.sheet_to_json(sheet);
        } else {
            console.error("‚ùå Error: Formato de archivo no v√°lido");
            return NextResponse.json({ error: "Formato de archivo no v√°lido. Debe ser .xlsx o .csv" }, { status: 400 });
        }

        if (clientes.length === 0) {
            console.error("‚ùå Error: El archivo est√° vac√≠o o tiene formato incorrecto");
            return NextResponse.json({ error: "El archivo est√° vac√≠o o no tiene formato v√°lido" }, { status: 400 });
        }

        console.log("üìå Clientes cargados desde archivo:", clientes);

        const clientesProcesados = [];
        const mongoClient = await clientPromise;
        const db = mongoClient.db(process.env.MONGODB_DB);

        for (const cliente of clientes) {
            let { Numero, Nombre, Asesor } = cliente;
            console.log("gaaaaaaaaaaaaaaaaaa", cliente);

            if (!Numero || !Nombre) {
                console.warn("‚ùó Cliente omitido por datos faltantes:", cliente);
                continue;
            }

            Numero = String(Numero).trim();
            if (!Numero.startsWith("+51")) {
                Numero = `+51${Numero}`;
            }

            console.log(`üîç Buscando cliente con n√∫mero: ${Numero}`);

            // üìå Buscar si el cliente existe en MySQL
            let clienteExistente = await prisma.cliente.findFirst({
                where: { celular: Numero },
            });

            // üìå Buscar si el cliente existe en MongoDB
            let clienteMongo = await db.collection("clientes").findOne({ celular: Numero });

            // üìå Si el cliente NO existe en MySQL, crearlo
            if (!clienteExistente) {
                console.log(`üîπ Cliente no encontrado en MySQL, creando nuevo: ${Nombre}`);
                try {
                    clienteExistente = await prisma.cliente.create({
                        data: {
                            celular: Numero,
                            nombre: Nombre,
                            documento_identidad: "",
                            tipo_documento: "Desconocido",
                            estado: "en seguimiento",
                            gestor: Asesor, 
                        },
                    });
                    console.log(`‚úÖ Cliente creado en MySQL con ID: ${clienteExistente.cliente_id}`);
                } catch (err) {
                    console.error("‚ùå Error al crear cliente en MySQL:", err);
                    continue;
                }
            } else {
                console.log(`‚úÖ Cliente ya existe en MySQL con ID: ${clienteExistente.cliente_id}`);
            }

            // üìå Si el cliente NO existe en MongoDB, crearlo
            if (!clienteMongo) {
                console.log(`üîπ Cliente no encontrado en MongoDB, creando nuevo: ${Nombre}`);
                try {
                    const nuevoClienteMongo = {
                        id_cliente: `cli_${clienteExistente.cliente_id}`,
                        nombre: Nombre,
                        celular: Numero,
                        correo: "",
                        conversaciones: [], // Inicialmente sin conversaciones
                    };

                    await db.collection("clientes").insertOne(nuevoClienteMongo);
                    console.log(`‚úÖ Cliente creado en MongoDB con ID: cli_${clienteExistente.cliente_id}`);
                } catch (err) {
                    console.error("‚ùå Error al crear cliente en MongoDB:", err);
                    continue;
                }
            } else {
                console.log(`‚úÖ Cliente ya existe en MongoDB con ID: ${clienteMongo.id_cliente}`);
            }

            const clienteId = clienteExistente.cliente_id;

            // üìå Verificar si el cliente ya est√° en la campa√±a
            let clienteCampanhaExistente = await prisma.cliente_campanha.findFirst({
                where: {
                    cliente_id: clienteId,
                    campanha_id: campanhaId,
                },
            });

            if (!clienteCampanhaExistente) {
                console.log(`üîπ Cliente ${clienteId} no est√° en la campa√±a, agregando...`);
                try {
                    await prisma.cliente_campanha.create({
                        data: {
                            cliente_id: clienteId,
                            campanha_id: campanhaId,
                        },
                    });
                    console.log(`‚úÖ Cliente ${clienteId} agregado a campa√±a ${campanhaId}`);
                } catch (err) {
                    console.error("‚ùå Error al agregar cliente a campa√±a:", err);
                    continue;
                }
            } else {
                console.log(`‚ö†Ô∏è Cliente ${clienteId} ya est√° en la campa√±a, omitiendo...`);
            }

            clientesProcesados.push({
                cliente_id: clienteId,
                nombre: clienteExistente.nombre,
                celular: clienteExistente.celular,
                gestor: clienteExistente.gestor
            });
        }

        console.log(`‚úÖ Carga de clientes completada con √©xito. Total procesados: ${clientesProcesados.length}`);

        return NextResponse.json({
            message: `Clientes procesados con √©xito en la campa√±a ${campanhaId}`,
            clientes: clientesProcesados,
        });

    } catch (error) {
        console.error("‚ùå Error al cargar clientes:", error);
        return NextResponse.json({ error: "Error al procesar el archivo" }, { status: 500 });
    }
}

// üîπ Obtener clientes de una campa√±a
export async function GET(req, { params }) {
  try {
    const clientes = await prisma.cliente_campanha.findMany({
      where: { campanha_id: parseInt(params.id) },
      include: { cliente: true },
    });

    return NextResponse.json(clientes);
  } catch (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// üîπ Eliminar cliente de campa√±a
export async function DELETE(req, { params }) {
  try {
    const { cliente_id } = await req.json();
    await prisma.cliente_campanha.deleteMany({
      where: { campanha_id: parseInt(params.id), cliente_id },
    });

    return NextResponse.json({ message: "Cliente eliminado" });
  } catch (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
